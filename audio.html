<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeatBroadcast</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.5.3/qrcode.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --background: #0f0f23;
            --surface: #1a1a2e;
            --surface-light: #252545;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --border: #374151;
            --gradient: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.connected { background: var(--success); }
        .status-dot.connecting { background: var(--warning); animation: pulse 2s infinite; }
        .status-dot.error { background: var(--danger); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .container {
            width: 100%;
            max-width: 600px;
            background: var(--surface);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: var(--surface-light);
        }

        .tab {
            flex: 1;
            padding: 1rem 2rem;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .tab:hover {
            color: var(--text);
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .tab-content {
            padding: 2rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        .input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            transition: border-color 0.2s ease;
        }

        .input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .input::placeholder {
            color: var(--text-muted);
        }

        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
        }

        .button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .button.secondary {
            background: var(--surface-light);
            color: var(--text);
        }

        .button.secondary:hover {
            background: var(--border);
        }

        .button.danger {
            background: var(--danger);
        }

        .button.danger:hover {
            background: #dc2626;
        }

        .button.success {
            background: var(--success);
        }

        .button.success:hover {
            background: #059669;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .card {
            background: var(--background);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .card-description {
            color: var(--text-muted);
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }

        .qr-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
            background: white;
            border-radius: 12px;
            margin: 1rem 0;
        }

        .room-info {
            text-align: center;
            background: var(--surface-light);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .room-name {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.25rem;
        }

        .room-id {
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: var(--text-muted);
            background: var(--background);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
        }

        .visualizer {
            height: 80px;
            background: var(--background);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 2px;
            margin: 1rem 0;
        }

        .bar {
            width: 4px;
            background: var(--primary);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 2px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: var(--background);
            border-radius: 8px;
            margin: 1rem 0;
        }

        .volume-slider {
            flex: 1;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .connections-list {
            background: var(--background);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .connection-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--surface-light);
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }

        .connection-item:last-child {
            margin-bottom: 0;
        }

        .connection-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--success);
            color: white;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.875rem;
        }

        .alert.info {
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
        }

        .alert.warning {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            color: #fbbf24;
        }

        .alert.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
        }

        .alert.error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            color: #fca5a5;
        }

        @media (max-width: 768px) {
            .header {
                padding: 1rem;
            }
            
            .main {
                padding: 1rem;
            }
            
            .tab-content {
                padding: 1.5rem;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .button {
                width: 100%;
            }
        }

        .hidden {
            display: none;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="logo">🎵 BeatBroadcast</div>
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Initializing...</span>
            </div>
        </header>

        <main class="main">
            <div class="container">
                <div class="tabs">
                    <button class="tab active" data-tab="create">Create Broadcast</button>
                    <button class="tab" data-tab="join">Join Broadcast</button>
                </div>

                <!-- Create Broadcast Tab -->
                <div class="tab-content" id="createTab">
                    <div class="card">
                        <div class="card-title">Start Broadcasting</div>
                        <div class="card-description">
                            Share your system audio with multiple devices in perfect sync
                        </div>

                        <div class="form-group">
                            <label class="label" for="broadcastName">Broadcast Name</label>
                            <input 
                                type="text" 
                                id="broadcastName" 
                                class="input" 
                                placeholder="Enter a name for your broadcast"
                                maxlength="50"
                            >
                        </div>

                        <div class="alert info">
                            <strong>📋 How to share system audio:</strong><br>
                            1. Click "Start Broadcasting" below<br>
                            2. Select your screen or application<br>
                            3. ✅ <strong>Check "Share audio"</strong> in the dialog<br>
                            4. Share the QR code or Room ID with listeners
                        </div>

                        <div class="button-group">
                            <button class="button success" id="startSystemBtn">
                                <span class="loading-spinner hidden" id="startSystemSpinner"></span>
                                Start Broadcasting (System Audio)
                            </button>
                            <button class="button secondary" id="startMicBtn">
                                Start Broadcasting (Microphone)
                            </button>
                        </div>

                        <button class="button danger hidden" id="stopBroadcastBtn">
                            Stop Broadcasting
                        </button>
                    </div>

                    <!-- Broadcasting State -->
                    <div class="hidden fade-in" id="broadcastingState">
                        <div class="room-info">
                            <div class="room-name" id="currentRoomName">My Broadcast</div>
                            <div class="room-id">Room ID: <span id="currentRoomId"></span></div>
                        </div>

                        <div class="qr-container">
                            <div id="qrcode"></div>
                            <div style="color: #374151; font-size: 0.875rem;">
                                Scan to join this broadcast
                            </div>
                        </div>

                        <div class="visualizer" id="broadcasterVisualizer">
                            <!-- Bars will be generated here -->
                        </div>

                        <div class="connections-list">
                            <div style="font-weight: 600; margin-bottom: 1rem;">
                                Connected Listeners: <span id="listenerCount">0</span>
                            </div>
                            <div id="listenersList">
                                <div style="color: var(--text-muted); font-size: 0.875rem; text-align: center; padding: 2rem;">
                                    Waiting for listeners to join...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Join Broadcast Tab -->
                <div class="tab-content hidden" id="joinTab">
                    <div class="card">
                        <div class="card-title">Join a Broadcast</div>
                        <div class="card-description">
                            Connect to an existing broadcast to listen to synchronized audio
                        </div>

                        <div class="form-group">
                            <label class="label" for="roomIdInput">Room ID</label>
                            <input 
                                type="text" 
                                id="roomIdInput" 
                                class="input" 
                                placeholder="Enter Room ID or scan QR code"
                                maxlength="10"
                            >
                        </div>

                        <div class="alert info">
                            Get the Room ID from the broadcaster or scan their QR code to connect automatically.
                        </div>

                        <div class="button-group">
                            <button class="button success" id="joinBroadcastBtn">
                                <span class="loading-spinner hidden" id="joinSpinner"></span>
                                Join Broadcast
                            </button>
                            <button class="button danger hidden" id="leaveBroadcastBtn">
                                Leave Broadcast
                            </button>
                        </div>
                    </div>

                    <!-- Listening State -->
                    <div class="hidden fade-in" id="listeningState">
                        <div class="room-info">
                            <div class="room-name" id="connectedRoomName">Connected to Broadcast</div>
                            <div class="room-id">Room ID: <span id="connectedRoomId"></span></div>
                        </div>

                        <div class="volume-control">
                            <span>🔊</span>
                            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                            <span id="volumeValue">50%</span>
                        </div>

                        <div class="visualizer" id="listenerVisualizer">
                            <!-- Bars will be generated here -->
                        </div>

                        <div class="alert success">
                            🎵 Connected! You're now listening to the synchronized audio stream.
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        class BeatBroadcastApp {
            constructor() {
                this.currentTab = 'create';
                this.state = {
                    mode: null, // 'broadcaster' | 'listener'
                    roomId: null,
                    roomName: null,
                    isConnected: false,
                    isConnecting: false,
                    localStream: null,
                    audioOnlyStream: null,
                    remoteAudio: null,
                    peerConnections: new Map(),
                    audioContext: null,
                    analyser: null,
                    listeners: new Set()
                };
                
                this.signalingEndpoint = 'https://audio-broadcast-signaling-default-rtdb.firebaseio.com/';
                this.pollingInterval = null;
                this.lastMessageTime = 0;
                this.localSignalingChannel = null;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.createVisualizers();
                this.updateConnectionStatus('disconnected', 'Ready');
                
                // Handle URL parameters for QR joins
                const urlParams = new URLSearchParams(window.location.search);
                const roomParam = urlParams.get('room');
                if (roomParam) {
                    this.switchTab('join');
                    document.getElementById('roomIdInput').value = roomParam;
                }
            }

            setupEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.switchTab(tab.dataset.tab);
                    });
                });

                // Broadcasting controls
                document.getElementById('startSystemBtn').addEventListener('click', () => {
                    this.startBroadcast('system');
                });
                
                document.getElementById('startMicBtn').addEventListener('click', () => {
                    this.startBroadcast('microphone');
                });
                
                document.getElementById('stopBroadcastBtn').addEventListener('click', () => {
                    this.stopBroadcast();
                });

                // Listening controls
                document.getElementById('joinBroadcastBtn').addEventListener('click', () => {
                    this.joinBroadcast();
                });
                
                document.getElementById('leaveBroadcastBtn').addEventListener('click', () => {
                    this.leaveBroadcast();
                });

                // Volume control
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    const volume = e.target.value / 100;
                    document.getElementById('volumeValue').textContent = e.target.value + '%';
                    
                    if (this.state.remoteAudio) {
                        this.state.remoteAudio.volume = volume;
                    }
                });

                // Enter key support for inputs
                document.getElementById('roomIdInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.joinBroadcast();
                    }
                });
                
                document.getElementById('broadcastName').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.startBroadcast('system');
                    }
                });
            }

            switchTab(tabName) {
                this.currentTab = tabName;
                
                // Update tab buttons
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Show/hide tab content
                document.getElementById('createTab').classList.toggle('hidden', tabName !== 'create');
                document.getElementById('joinTab').classList.toggle('hidden', tabName !== 'join');
            }

            updateConnectionStatus(status, text) {
                const statusDot = document.getElementById('connectionStatus');
                const statusText = document.getElementById('connectionText');
                
                statusDot.className = `status-dot ${status}`;
                statusText.textContent = text;
            }

            generateRoomId() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }

            async startBroadcast(audioSource) {
                const broadcastName = document.getElementById('broadcastName').value.trim() || 'Unnamed Broadcast';
                
                this.showLoading('startSystemBtn', true);
                this.updateConnectionStatus('connecting', 'Starting broadcast...');
                
                try {
                    if (audioSource === 'system') {
                        this.state.localStream = await navigator.mediaDevices.getDisplayMedia({
                            video: true,
                            audio: {
                                echoCancellation: false,
                                noiseSuppression: false,
                                autoGainControl: false,
                                sampleRate: 48000
                            }
                        });
                        
                        const audioTracks = this.state.localStream.getAudioTracks();
                        if (audioTracks.length === 0) {
                            throw new Error('No audio track found. Please check "Share audio" when sharing your screen.');
                        }
                        
                        this.state.audioOnlyStream = new MediaStream(audioTracks);
                    } else {
                        this.state.localStream = await navigator.mediaDevices.getUserMedia({
                            audio: {
                                echoCancellation: true,
                                noiseSuppression: true,
                                autoGainControl: true,
                                sampleRate: 48000
                            }
                        });
                        
                        this.state.audioOnlyStream = this.state.localStream;
                    }
                    
                    this.state.mode = 'broadcaster';
                    this.state.roomId = this.generateRoomId();
                    this.state.roomName = broadcastName;
                    this.state.isConnected = true;
                    
                    this.setupAudioAnalysis(this.state.audioOnlyStream);
                    this.setupSignaling();
                    this.generateQRCode();
                    this.showBroadcastingState();
                    
                    // Handle stream ending
                    if (audioSource === 'system') {
                        this.state.localStream.getVideoTracks()[0].addEventListener('ended', () => {
                            this.stopBroadcast();
                        });
                    }
                    
                    this.updateConnectionStatus('connected', `Broadcasting "${broadcastName}"`);
                    
                } catch (error) {
                    console.error('Error starting broadcast:', error);
                    this.updateConnectionStatus('error', 'Failed to start broadcast');
                    
                    let errorMessage = 'Could not start broadcast. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Please allow screen/microphone access.';
                    } else if (error.message.includes('No audio track')) {
                        errorMessage += 'Make sure to check "Share audio" when sharing your screen.';
                    } else {
                        errorMessage += 'Please try again.';
                    }
                    
                    this.showAlert('error', errorMessage);
                } finally {
                    this.showLoading('startSystemBtn', false);
                }
            }

            stopBroadcast() {
                // Clean up streams
                if (this.state.localStream) {
                    this.state.localStream.getTracks().forEach(track => track.stop());
                }
                if (this.state.audioOnlyStream && this.state.audioOnlyStream !== this.state.localStream) {
                    this.state.audioOnlyStream.getTracks().forEach(track => track.stop());
                }
                
                // Clean up peer connections
                this.state.peerConnections.forEach(pc => pc.close());
                this.state.peerConnections.clear();
                
                // Clean up audio context
                if (this.state.audioContext) {
                    this.state.audioContext.close();
                }
                
                // Stop signaling
                this.stopSignaling();
                
                // Reset state
                this.state = {
                    ...this.state,
                    mode: null,
                    roomId: null,
                    roomName: null,
                    isConnected: false,
                    localStream: null,
                    audioOnlyStream: null,
                    audioContext: null,
                    analyser: null,
                    listeners: new Set()
                };
                
                this.hideBroadcastingState();
                this.updateConnectionStatus('disconnected', 'Ready');
            }

            async joinBroadcast() {
                const roomId = document.getElementById('roomIdInput').value.trim();
                if (!roomId) {
                    this.showAlert('warning', 'Please enter a Room ID');
                    return;
                }
                
                this.showLoading('joinBroadcastBtn', true);
                this.updateConnectionStatus('connecting', 'Joining broadcast...');
                
                try {
                    this.state.mode = 'listener';
                    this.state.roomId = roomId;
                    this.state.isConnecting = true;
                    
                    this.setupSignaling();
                    await this.sendSignalingMessage('join-request', {
                        listenerName: `Listener-${Date.now().toString().slice(-4)}`
                    });
                    
                    this.showListeningState();
                    this.updateConnectionStatus('connecting', 'Waiting for broadcaster...');
                    
                    // Set timeout for connection
                    setTimeout(() => {
                        if (this.state.isConnecting && this.state.peerConnections.size === 0) {
                            this.updateConnectionStatus('error', 'Connection timeout');
                            this.showAlert('error', 'Could not connect to broadcast. Please check the Room ID and try again.');
                        }
                    }, 15000);
                    
                } catch (error) {
                    console.error('Error joining broadcast:', error);
                    this.updateConnectionStatus('error', 'Failed to join');
                    this.showAlert('error', 'Could not join broadcast. Please try again.');
                } finally {
                    this.showLoading('joinBroadcastBtn', false);
                }
            }

            leaveBroadcast() {
                // Clean up peer connections
                this.state.peerConnections.forEach(pc => pc.close());
                this.state.peerConnections.clear();
                
                // Clean up remote audio
                if (this.state.remoteAudio) {
                    this.state.remoteAudio.remove();
                    this.state.remoteAudio = null;
                }
                
                // Clean up audio context
                if (this.state.audioContext) {
                    this.state.audioContext.close();
                }
                
                // Stop signaling
                this.stopSignaling();
                
                // Reset state
                this.state = {
                    ...this.state,
                    mode: null,
                    roomId: null,
                    roomName: null,
                    isConnected: false,
                    isConnecting: false,
                    remoteAudio: null,
                    audioContext: null,
                    analyser: null
                };
                
                this.hideListeningState();
                document.getElementById('roomIdInput').value = '';
                this.updateConnectionStatus('disconnected', 'Ready');
            }

            // UI State Management
            showBroadcastingState() {
                document.getElementById('currentRoomName').textContent = this.state.roomName;
                document.getElementById('currentRoomId').textContent = this.state.roomId;
                document.getElementById('broadcastingState').classList.remove('hidden');
                document.getElementById('stopBroadcastBtn').classList.remove('hidden');
                document.getElementById('startSystemBtn').classList.add('hidden');
                document.getElementById('startMicBtn').classList.add('hidden');
            }

            hideBroadcastingState() {
                document.getElementById('broadcastingState').classList.add('hidden');
                document.getElementById('stopBroadcastBtn').classList.add('hidden');
                document.getElementById('startSystemBtn').classList.remove('hidden');
                document.getElementById('startMicBtn').classList.remove('hidden');
            }

            showListeningState() {
                document.getElementById('connectedRoomId').textContent = this.state.roomId;
                document.getElementById('listeningState').classList.remove('hidden');
                document.getElementById('leaveBroadcastBtn').classList.remove('hidden');
                document.getElementById('joinBroadcastBtn').classList.add('hidden');
            }

            hideListeningState() {
                document.getElementById('listeningState').classList.add('hidden');
                document.getElementById('leaveBroadcastBtn').classList.add('hidden');
                document.getElementById('joinBroadcastBtn').classList.remove('hidden');
            }

            showLoading(buttonId, show) {
                const button = document.getElementById(buttonId);
                const spinner = button.querySelector('.loading-spinner') || 
                               document.getElementById(buttonId.replace('Btn', 'Spinner'));
                
                if (spinner) {
                    spinner.classList.toggle('hidden', !show);
                }
                button.disabled = show;
            }

            showAlert(type, message) {
                // Remove existing alerts
                document.querySelectorAll('.alert.temp').forEach(alert => alert.remove());
                
                const alert = document.createElement('div');
                alert.className = `alert ${type} temp fade-in`;
                alert.innerHTML = message;
                
                const activeTab = document.querySelector('.tab-content:not(.hidden)');
                activeTab.insertBefore(alert, activeTab.firstChild);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.remove();
                    }
                }, 5000);
            }

            // WebRTC and Signaling (simplified implementation for demo)
            setupSignaling() {
                // Use Firebase for cross-device signaling with BroadcastChannel fallback
                this.startSignalingPolling();
            }

            stopSignaling() {
                if (this.pollingInterval) {
                    clearInterval(this.pollingInterval);
                    this.pollingInterval = null;
                }
                if (this.localSignalingChannel) {
                    this.localSignalingChannel.close();
                    this.localSignalingChannel = null;
                }
            }

            async sendSignalingMessage(type, data) {
                const message = {
                    type,
                    roomId: this.state.roomId,
                    data,
                    from: this.state.mode,
                    timestamp: Date.now(),
                    id: Math.random().toString(36).substring(7)
                };

                try {
                    const response = await fetch(`${this.signalingEndpoint}signals/${this.state.roomId}.json`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(message)
                    });
                    
                    if (!response.ok) throw new Error('Network signaling failed');
                } catch (error) {
                    console.warn('Network signaling failed, using local fallback:', error);
                    if (!this.localSignalingChannel) {
                        this.localSignalingChannel = new BroadcastChannel('beatbroadcast-signaling');
                    }
                    this.localSignalingChannel.postMessage(message);
                }
            }

            async startSignalingPolling() {
                if (this.pollingInterval) clearInterval(this.pollingInterval);

                this.pollingInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`${this.signalingEndpoint}signals/${this.state.roomId}.json`);
                        if (response.ok) {
                            const messages = await response.json();
                            if (messages) {
                                Object.values(messages).forEach(message => {
                                    if (message.from !== this.state.mode && 
                                        message.timestamp > this.lastMessageTime) {
                                        this.handleSignalingMessage(message);
                                        this.lastMessageTime = message.timestamp;
                                    }
                                });
                            }
                        }
                    } catch (error) {
                        console.warn('Polling failed:', error);
                    }
                }, 2000);

                // Local signaling fallback
                if (!this.localSignalingChannel) {
                    this.localSignalingChannel = new BroadcastChannel('beatbroadcast-signaling');
                    this.localSignalingChannel.addEventListener('message', (event) => {
                        if (event.data.roomId === this.state.roomId && 
                            event.data.from !== this.state.mode) {
                            this.handleSignalingMessage(event.data);
                        }
                    });
                }
            }

            async handleSignalingMessage(message) {
                const { type, data, from } = message;
                
                switch (type) {
                    case 'join-request':
                        if (this.state.mode === 'broadcaster') {
                            await this.handleJoinRequest(data, from);
                        }
                        break;
                    case 'offer':
                        if (this.state.mode === 'listener') {
                            await this.handleOffer(data);
                        }
                        break;
                    case 'answer':
                        if (this.state.mode === 'broadcaster') {
                            await this.handleAnswer(data);
                        }
                        break;
                    case 'ice-candidate':
                        await this.handleIceCandidate(data);
                        break;
                }
            }

            async handleJoinRequest(data, from) {
                const { listenerName } = data;
                const peerId = `listener-${Date.now()}`;
                
                try {
                    const pc = await this.createPeerConnection(peerId);
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    await this.sendSignalingMessage('offer', { offer, peerId });
                    
                    // Add to listeners list
                    this.state.listeners.add({ id: peerId, name: listenerName });
                    this.updateListenersList();
                } catch (error) {
                    console.error('Error handling join request:', error);
                }
            }

            async handleOffer(data) {
                const { offer, peerId } = data;
                
                try {
                    const pc = await this.createPeerConnection(peerId);
                    await pc.setRemoteDescription(new RTCSessionDescription(offer));
                    
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    await this.sendSignalingMessage('answer', { answer, peerId });
                } catch (error) {
                    console.error('Error handling offer:', error);
                }
            }

            async handleAnswer(data) {
                const { answer, peerId } = data;
                const pc = this.state.peerConnections.get(peerId);
                
                if (pc) {
                    try {
                        await pc.setRemoteDescription(new RTCSessionDescription(answer));
                    } catch (error) {
                        console.error('Error handling answer:', error);
                    }
                }
            }

            async handleIceCandidate(data) {
                const { candidate, peerId } = data;
                const pc = this.state.peerConnections.get(peerId);
                
                if (pc && candidate) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (error) {
                        console.error('Error adding ICE candidate:', error);
                    }
                }
            }

            async createPeerConnection(peerId) {
                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                });

                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendSignalingMessage('ice-candidate', {
                            candidate: event.candidate,
                            peerId
                        });
                    }
                };

                pc.onconnectionstatechange = () => {
                    console.log(`Peer ${peerId} connection state: ${pc.connectionState}`);
                    
                    if (pc.connectionState === 'connected') {
                        if (this.state.mode === 'listener') {
                            this.state.isConnecting = false;
                            this.state.isConnected = true;
                            this.updateConnectionStatus('connected', 'Connected to broadcast');
                        }
                    } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                        this.state.peerConnections.delete(peerId);
                        if (this.state.mode === 'broadcaster') {
                            this.updateListenersList();
                        }
                    }
                };

                if (this.state.mode === 'broadcaster' && this.state.audioOnlyStream) {
                    this.state.audioOnlyStream.getTracks().forEach(track => {
                        pc.addTrack(track, this.state.audioOnlyStream);
                    });
                } else if (this.state.mode === 'listener') {
                    pc.ontrack = (event) => {
                        if (event.track.kind === 'audio') {
                            this.handleRemoteAudio(event.streams[0]);
                        }
                    };
                }

                this.state.peerConnections.set(peerId, pc);
                return pc;
            }

            handleRemoteAudio(stream) {
                // Remove existing audio
                if (this.state.remoteAudio) {
                    this.state.remoteAudio.remove();
                }
                
                // Create new audio element
                this.state.remoteAudio = document.createElement('audio');
                this.state.remoteAudio.srcObject = stream;
                this.state.remoteAudio.autoplay = true;
                this.state.remoteAudio.volume = document.getElementById('volumeSlider').value / 100;
                document.body.appendChild(this.state.remoteAudio);
                
                // Setup audio analysis
                this.setupAudioAnalysis(stream);
                
                // Update room name if available (would come from signaling in real implementation)
                document.getElementById('connectedRoomName').textContent = `Connected to Broadcast`;
            }

            updateListenersList() {
                const count = this.state.peerConnections.size;
                document.getElementById('listenerCount').textContent = count;
                
                const listenersList = document.getElementById('listenersList');
                
                if (count === 0) {
                    listenersList.innerHTML = `
                        <div style="color: var(--text-muted); font-size: 0.875rem; text-align: center; padding: 2rem;">
                            Waiting for listeners to join...
                        </div>
                    `;
                } else {
                    listenersList.innerHTML = '';
                    let listenerIndex = 1;
                    this.state.peerConnections.forEach((pc, peerId) => {
                        const item = document.createElement('div');
                        item.className = 'connection-item';
                        item.innerHTML = `
                            <span>Listener ${listenerIndex++}</span>
                            <span class="connection-status">Connected</span>
                        `;
                        listenersList.appendChild(item);
                    });
                }
            }

            // Audio Visualization
            setupAudioAnalysis(stream) {
                if (this.state.audioContext) {
                    this.state.audioContext.close();
                }
                
                this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.state.analyser = this.state.audioContext.createAnalyser();
                this.state.analyser.fftSize = 256;
                this.state.analyser.smoothingTimeConstant = 0.8;
                
                const source = this.state.audioContext.createMediaStreamSource(stream);
                source.connect(this.state.analyser);
                
                const visualizerId = this.state.mode === 'broadcaster' ? 'broadcasterVisualizer' : 'listenerVisualizer';
                this.startVisualization(visualizerId);
            }

            createVisualizers() {
                ['broadcasterVisualizer', 'listenerVisualizer'].forEach(id => {
                    const container = document.getElementById(id);
                    container.innerHTML = '';
                    
                    for (let i = 0; i < 32; i++) {
                        const bar = document.createElement('div');
                        bar.className = 'bar';
                        container.appendChild(bar);
                    }
                });
            }

            startVisualization(visualizerId) {
                if (!this.state.analyser) return;
                
                const bars = document.querySelectorAll(`#${visualizerId} .bar`);
                const bufferLength = this.state.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const animate = () => {
                    if (!this.state.analyser) return;
                    
                    this.state.analyser.getByteFrequencyData(dataArray);
                    
                    bars.forEach((bar, index) => {
                        const value = dataArray[index * 4] || 0;
                        const height = Math.max(2, (value / 255) * 60);
                        bar.style.height = height + 'px';
                        bar.style.opacity = 0.4 + (value / 255) * 0.6;
                    });
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }

            generateQRCode() {
                const qrData = JSON.stringify({
                    roomId: this.state.roomId,
                    roomName: this.state.roomName,
                    url: `${window.location.origin}${window.location.pathname}?room=${this.state.roomId}`
                });
                
                document.getElementById('qrcode').innerHTML = '';
                QRCode.toCanvas(document.getElementById('qrcode'), qrData, {
                    width: 200,
                    margin: 2,
                    color: {
                        dark: '#000000',
                        light: '#FFFFFF'
                    }
                });
            }
        }

        // Initialize the app
        const app = new BeatBroadcastApp();
    </script>
</body>
</html>